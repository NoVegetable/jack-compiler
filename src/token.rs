use logos::{Lexer, Logos};
use std::fmt::Display;
use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Default, Debug, Clone, PartialEq)]
pub enum LexicalError {
    InvalidInteger(ParseIntError),
    UnrecognizedKeyword(ParseKeywordError),
    UnrecognizedSymbol(ParseSymbolError),
    #[default]
    InvalidToken,
}

impl From<ParseIntError> for LexicalError {
    fn from(err: ParseIntError) -> Self {
        LexicalError::InvalidInteger(err)
    }
}

impl From<ParseKeywordError> for LexicalError {
    fn from(err: ParseKeywordError) -> Self {
        LexicalError::UnrecognizedKeyword(err)
    }
}

impl From<ParseSymbolError> for LexicalError {
    fn from(err: ParseSymbolError) -> Self {
        LexicalError::UnrecognizedSymbol(err)
    }
}

#[derive(Logos, Debug, Clone, PartialEq)]
#[logos(skip r"(?m)//.*?$", skip r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/", skip r"[ \t\n\r\f]+", error = LexicalError)]
pub enum Token {
    #[regex(
        "class|constructor|function|method|field|static|var|int|char|boolean|void|true|false|null|this|let|do|if|else|while|return",
        |lex| Keyword::from_str(lex.slice())
    )]
    Keyword(Keyword),

    #[regex(r"[{}()\[\].,;+*\/&|<>=~-]", |lex| Symbol::from_str(lex.slice()))]
    Symbol(Symbol),

    #[regex(r#""[^"\n]*""#, |lex| lex.slice().to_string())]
    StringConstant(String),

    #[regex(r"[0-9]+", |lex| lex.slice().parse())]
    IntegerConstant(u16),

    #[regex(r"[a-zA-Z_][a-zA-Z0-9_]*", |lex| lex.slice().to_string())]
    Identifier(String),
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Keyword {
    Class,
    Constructor,
    Function,
    Method,
    Field,
    Static,
    Var,
    Int,
    Char,
    Boolean,
    Void,
    True,
    False,
    Null,
    This,
    Let,
    Do,
    If,
    Else,
    While,
    Return,
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Symbol {
    /// `{`
    OpenBrace,
    /// `}`
    CloseBrace,
    /// `(`
    OpenParen,
    /// `)`
    CloseParen,
    /// `[`
    OpenBracket,
    /// `]`
    CloseBracket,
    /// `.`
    Dot,
    /// `,`
    Comma,
    /// `;`
    Semi,
    /// `+`
    Plus,
    /// `-`
    Minus,
    /// `*`
    Star,
    /// `/`
    Slash,
    /// `&`
    And,
    /// `|`
    Or,
    /// `<`
    Lt,
    /// `>`
    Gt,
    /// `=`
    Eq,
    /// `~`
    Tilde,
}

#[inline]
pub fn lexer<'source>(source: &'source <Token as Logos>::Source) -> Lexer<'source, Token> {
    Token::lexer(source)
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ParseKeywordError {
    unrecognized_keyword: String,
}

impl FromStr for Keyword {
    type Err = ParseKeywordError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        use Keyword::*;
        match s {
            "class" => Ok(Class),
            "constructor" => Ok(Constructor),
            "function" => Ok(Function),
            "method" => Ok(Method),
            "field" => Ok(Field),
            "static" => Ok(Static),
            "var" => Ok(Var),
            "int" => Ok(Int),
            "char" => Ok(Char),
            "boolean" => Ok(Boolean),
            "void" => Ok(Void),
            "true" => Ok(True),
            "false" => Ok(False),
            "null" => Ok(Null),
            "this" => Ok(This),
            "let" => Ok(Let),
            "do" => Ok(Do),
            "if" => Ok(If),
            "else" => Ok(Else),
            "while" => Ok(While),
            "return" => Ok(Return),
            _ => Err(ParseKeywordError {
                unrecognized_keyword: String::from(s),
            }),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ParseSymbolError {
    unrecognized_symbol: String,
}

impl FromStr for Symbol {
    type Err = ParseSymbolError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        use Symbol::*;
        match s {
            "{" => Ok(OpenBrace),
            "}" => Ok(CloseBrace),
            "(" => Ok(OpenParen),
            ")" => Ok(CloseParen),
            "[" => Ok(OpenBracket),
            "]" => Ok(CloseBracket),
            "." => Ok(Dot),
            "," => Ok(Comma),
            ";" => Ok(Semi),
            "+" => Ok(Plus),
            "-" => Ok(Minus),
            "*" => Ok(Star),
            "/" => Ok(Slash),
            "&" => Ok(And),
            "|" => Ok(Or),
            "<" => Ok(Lt),
            ">" => Ok(Gt),
            "=" => Ok(Eq),
            "~" => Ok(Tilde),
            _ => Err(ParseSymbolError {
                unrecognized_symbol: String::from(s),
            }),
        }
    }
}

// This is required because tokens are included in the error message generated by LALRPOP when it
// fails.
impl Display for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}
